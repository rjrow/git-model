

$onglobal

*
* --- include file generated by interface
*
$include 'mtrmcp_inc.gms'
*
* --- Data file to use
*
$if not setglobal ds $set ds 'main_data_out.gdx'

*
* --- load basis data and parameters from GTAP agg,
*
$batinclude 'gtap6data.gms'



* -------------------------------------------------------------------------------------------------------------------
*
*  The model currently supports three options for factor markets:
*
*  (1) Fully mobile (set mf)
*  (2) sluggish (CET), i.e. factor prices between sector will deviate as factor are not fully mobile (set sf)
*  (3) Fixed prices, e.g. to allow for endogenous unemployment (set fpf)
*
* -------------------------------------------------------------------------------------------------------------------
  mf(f)  = yes;
  mf(sf) = yes;

  set fpf(f) "Factors with fixed price";
  option kill=fpf;
  option kill=sf;



  set alternateFactorNames / lab,sklLab,cap,capital,skl,unSkLab,res, natRes, lnd, land /;

$ifi "%labmarket%"       == "SLUGGISH" sf(f) $ sameas(f,"unskLab")       = yes;
$ifi "%labmarket%"       == "SLUGGISH" sf(f) $ sameas(f,"Lab")           = yes;

$ifi "%sklMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"skLab")     = yes;
$ifi "%sklMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"skl")       = yes;

$ifi "%capitalMarket%"   == "SLUGGISH" sf(f) $ sameas(f,"capital")       = yes;
$ifi "%capitalMarket%"   == "SLUGGISH" sf(f) $ sameas(f,"cap")           = yes;

$ifi "%resMarket%"       == "SLUGGISH" sf(f) $ sameas(f,"res")           = yes;
$ifi "%resMarket%"       == "SLUGGISH" sf(f) $ sameas(f,"natRes")        = yes;

$ifi "%lndMarket%"       == "SLUGGISH" sf(f) $ sameas(f,"lnd")           = yes;
$ifi "%lndMarket%"       == "SLUGGISH" sf(f) $ sameas(f,"land")          = yes;

$ifi "%labmarket%"       == "FIXED_PRICE" fpf(f)  $ sameas(f,"unskLab")  = yes;
$ifi "%labmarket%"       == "FIXED_PRICE" fpf(f)  $ sameas(f,"Lab")      = yes;

$ifi "%sklMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"skLab")     = yes;
$ifi "%sklMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"skl")       = yes;

$ifi "%capitalMarket%"   == "FIXED_PRICE" fpf(f) $ sameas(f,"capital")   = yes;
$ifi "%capitalMarket%"   == "FIXED_PRICE" fpf(f) $ sameas(f,"cap")       = yes;

$ifi "%resMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"res")       = yes;
$ifi "%resMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"Natres")    = yes;

$ifi "%lndMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"ldn")       = yes;
$ifi "%lndMarket%"       == "FIXED_PRICE" fpf(f) $ sameas(f,"land")      = yes;

  sf(f) $ (etrae(f) eq inf) = NO;

  mf(f) $ sf(f)  = no;
  sf(f) $ fpf(f) = no;
  mf(f) $ fpf(f) = no;

  display sf,mf,fpf;
  alias (j,jj);


positive variables
         c(r)              "Consumption index"
         g(r)              "Government demand"
         y(i,r)            "Supply"
         m(i,r)            "Imports"
         yt(j)             "Transportation services"
         ft(f,r)           "Specific factor transformation"

         pc(r)             "Private consumption price index"
         pg(r)             "Public consumption price index"
         py(j,r)           "Domestic output price"
         pm(j,r)           "Import price"
         pt(j)             "Price transportation services"
         pf(f,r)           "Primary factors"
         ps(f,j,r)         "Sector-specific primary factors"

         ra(r)             "Income of Representative agent";

equations
         prf_c(r)          "Consumption"
         prf_g(r)          "Government demand"
         prf_y(i,r)        "Supply"
         prf_m(i,r)        "Imports"
         prf_yt(j)         "Transportation services"
         prf_ft(f,r)       "Factor transformation"

         mkt_pc(r)         "Private consumption price index"
         mkt_pg(r)         "Public consumption price index"
         mkt_py(j,r)       "Domestic output price"
         mkt_pm(j,r)       "Import price"
         mkt_pt(j)         "Transportation services"
         mkt_pf(f,r)       "Primary factors"
         mkt_ps(f,j,r)     "Specific factor"

         inc_ra(r)         "Representative agent";

* -------------------------------------------------------------------------------------------------------------------
*
*  Production block: price definitions, cost functions, zero profit condition
*
* -------------------------------------------------------------------------------------------------------------------

*        -----------------------------------------------------------------------------
*        Profit function for firms:

*        Value shares for firm inputs of factors and goods:

parameter         thetaf(f,j,r)     "Share of factor f on total factor costs"
                  thetad(i,j,r)     "Domestic share of intermediate input"
                  thetai(i,j,r)     "Share of intermediate input"
                  theta_f(j,r)      "Value added share of sectoral output";

alias (f,ff);

*
* --- share for each factor f on factor cost (vfm) plus factor taxes (rtf)
*

  thetaf(f,j,r) $ sum(ff,vfm(ff,j,r)*(1+rtf0(ff,j,r)))
         = vfm(f,j,r) * (1+rtf0(f,j,r)) / sum(ff, vfm(ff,j,r) * (1+rtf0(ff,j,r)) );

*
* --- share of domestic intermediate demand cost for product i by sector j
*     on total intermediate demand cost for product i by sector j
*

  thetad(i,j,r) $ (vdfm(i,j,r)*(1+rtfd0(i,j,r)) + vifm(i,j,r)*(1+rtfi0(i,j,r)))
         = vdfm(i,j,r)*(1+rtfd0(i,j,r)) /
                   (vdfm(i,j,r)*(1+rtfd0(i,j,r)) + vifm(i,j,r)*(1+rtfi0(i,j,r)));

*
* --- share of intermediate demand cost for product i by sector j
*     on total production cost of sector j
*

  thetai(i,j,r) $ vom(j,r)
         = (vdfm(i,j,r)*(1+rtfd0(i,j,r)) + vifm(i,j,r)*(1+rtfi0(i,j,r))) / vom(j,r);


*
* --- share of total factor cost on total production cost of sector j
*
  theta_f(j,r) $ vom(j,r) = sum(ff,vfm(ff,j,r)*(1+rtf0(ff,j,r))) / vom(j,r);

*
*        ------------------------------------------------------------------------------
*
*        User cost indices for factors, domestic and imported
*        intermediate inputs:
*
*        ------------------------------------------------------------------------------
*
Equations
*
 e_cf(j,r)      "Definition of sector specific value added prices, CES aggregate of factors"
 e_ci(i,j,r)    "Definition of sector specific price for intermediate, Armginton aggregate domestic/imported"
 e_cy(j,r)      "Definition of total cost price per sector, Leontief aggregate of intermediate and value added"

 e_p_pf(f,j,r)  "Definition of sector specific factor prices"
 e_p_d(i,j,r)   "Definition of sector specific intermediate prices from domestic origin"
 e_P_i(i,j,r)   "Definition of sector specific intermediate prices from imports"
;

Variables
 cf(j,r)        "Value added price"
 ci(i,j,r)      "Intermediate price per sector"
 cy(j,r)        "Per unit costs per sector"
 p_pf(f,j,r)    "Sector specific factor prices"
 p_d(i,j,r)     "Sector specific intermediate prices from domestic origin"
 P_i(i,j,r)     "Sector specific intermediate prices from imported origin"
;
*
* --- prices for outputs, imported origin and factors are unity in starting point
*
$setlocal homogtest 1


  py.l(j,r)    = 1 * %homogtest%;
  py.lo(j,r)   = 1.E-6;
  pm.l(j,r)    = 1 * %homogtest%;
  pm.lo(j,r)   = 1.E-6;
  pf.l(f,r)    = 1 * %homogtest%;
  ps.l(sf,j,r) = 1 * %homogtest%;
  ps.l(sf,j,r) = 1 * %homogtest%;

*
* --- sector specific factor prices, domestic origin,
*     by accounting for sector specific ad-valorem tax rates
*
*     mf: factors with uniform market
*     sf: sector specific factors
*

e_p_pf(f,j,r) $ (p_pf.range(f,j,r) ne 0) ..

  p_pf(f,j,r) =E= (pf(f,r) $ mf(f) + ps(f,j,r)   $ sf(f) + 1*%homogTest% $ fpf(f))  *(1+rtf(f,j,r))/(1+rtf0(f,j,r));

  p_pf.l(f,j,r) = (pf.l(f,r) $ mf(f) + ps.l(f,j,r) $ sf(f) + 1*%homogTest% $ fpf(f) )*(1+rtf(f,j,r))/(1+rtf0(f,j,r));
  p_pf.lo(f,j,r) $ (p_pf.range(f,j,r) ne 0) = 1.E-6;

*
* --- sector specific prices for intermediates, domestic origin,
*     by accounting for sector specific ad-valorem tax rates
*
e_p_d(i,j,r) $ vdfm(i,j,r) ..

  p_d(i,j,r) =E= py(i,r)*(1+rtfd(i,j,r))/(1+rtfd0(i,j,r));
  p_d.l(i,j,r) $ vdfm(i,j,r)
          = py.l(i,r)*(1+rtfd(i,j,r))/(1+rtfd0(i,j,r));
  p_d.lo(i,j,r) $ vdfm(i,j,r)  = 1.E-6;

*
* --- sector specific prices for intermediates, import origin,
*     by accounting for sector specific ad-valorem tax rates
*
e_P_i(i,j,r) $ vifm(i,j,r) ..

  p_i(i,j,r) =E= pm(i,r)*(1+rtfi(i,j,r))/(1+rtfi0(i,j,r));

  p_i.l(i,j,r) $ vifm(i,j,r)
    = pm.l(i,r)*(1+rtfi(i,j,r))/(1+rtfi0(i,j,r));
  p_i.lo(i,j,r) $ vifm(i,j,r) = 1.E-6;

*
*  --- Compensated (CES) cost functions for value added:
*
*parameter p_techProgFac(j,r);
*p_techProgFac(j,r) = 1;

 e_cf(j,r) $ ((esubva(j) ne 1) $ sum(f, thetaf(f,j,r))) ..

   cf(j,r) =E= sum(f $ thetaf(f,j,r), thetaf(f,j,r) * p_pf(f,j,r)**(1-esubva(j)))**(1/(1-esubva(j)));

 cf.fx(j,r) $ (esubva(j) eq 1) = 0;
 cf.fx(j,r) $ (not sum(f, thetaf(f,j,r))) = 0;

 cf.l(j,r)  $ ( (esubva(j) ne 1) $ sum(f, thetaf(f,j,r)))
   = sum(f  $ thetaf(f,j,r), thetaf(f,j,r) * p_pf.l(f,j,r)**(1-esubva(j)))**(1/(1-esubva(j)));

 cf.lo(j,r)  $ ( (esubva(j) ne 1) $ sum(f, thetaf(f,j,r))) = 1.E-6;
*
*  --- Compensated (CES) cost functions for intermediate
*      (Armington)
*
e_ci(i,j,r) $ thetai(i,j,r) ..

  ci(i,j,r) =E= ( (   (thetad(i,j,r)  * p_d(i,j,r)**(1-esubd(i))) $ thetad(i,j,r)     +
                  ( (1-thetad(i,j,r)) * p_i(i,j,r)**(1-esubd(i))) $ (1-thetad(i,j,r))    )**(1/(1-esubd(i))) );


  ci.l(i,j,r) $ thetai(i,j,r)
            =   ( (   (thetad(i,j,r)  * p_d.l(i,j,r)**(1-esubd(i))) $ thetad(i,j,r)    +
                  ( (1-thetad(i,j,r)) * p_i.l(i,j,r)**(1-esubd(i))) $ (1-thetad(i,j,r))  )**(1/(1-esubd(i))) );


  ci.lo(i,j,r) $ thetai(i,j,r) = 1.E-6;
*
* --- Leontief cost function: aggregates intermediate and value added
*
  e_cy(j,r) $ (sum(i, thetai(i,j,r)) + theta_f(j,r)) ..

  cy(j,r) =E= sum(i $ thetai(i,j,r), thetai(i,j,r) * ci(i,j,r)) + (theta_f(j,r)*cf(j,r)/p_techProgFac(j,r));

  cy.fx(j,r) $ ( (sum(i,thetai(i,j,r)) + theta_f(j,r)) eq 0) = %homogTest%;

  cy.l(j,r) $ (sum(i, thetai(i,j,r)) + theta_f(j,r))
   = sum(i $ thetai(i,j,r), thetai(i,j,r) * ci.l(i,j,r)) + (theta_f(j,r)*cf.l(j,r));

  cy.lo(j,r) $ (sum(i, thetai(i,j,r)) + theta_f(j,r)) = 1.E-6;
*
* --- zero profit conditions: per unit costs equal to output prices minus output tax
*
  option kill=prf_y.lo;
*  parameter p_priceShock(j,r);
*  p_priceShock(j,r) = 1;

  prf_y(j,r) $ (vom(j,r) and py.range(j,r)) ..     cy(j,r) =e= py(j,r) * (1-rto(j,r)) / p_priceShock(j,r);

*        $prod:y(j,r)$vom(j,r)      s:0    i.tl:esubd(i)  va:esubva(j)
*                 o:py(j,r)         q:vom(j,r)        a:ra(r)  t:rto(j,r)
*                 i:py(i,r)         q:vdfm(i,j,r)     p:(1+rtfd0(i,j,r)) i.tl:  a:ra(r) t:rtfd(i,j,r)
*                 i:pm(i,r)         q:vifm(i,j,r)     p:(1+rtfi0(i,j,r)) i.tl:  a:ra(r) t:rtfi(i,j,r)
*                 i:pf(f,r)         q:vfm(f,j,r)      p:(1+rtf0(f,j,r))  va:    a:ra(r) t:rtf(f,j,r)
*
*        -----------------------------------------------------------------------------
*
*
*        Profit function for international transportation services:

  prf_yt(j) $ vtw(j)..
         prod(r, py(j,r)**(vst(j,r)/vtw(j))) =e= pt(j);


* -------------------------------------------------------------------------------------------------------------------
*
*  Private consumption block: price definitions, cost functions, demand function
*
*
*  The model uses in its standard form a CD demand function, i.e. the budget shares are fixed.
*
*  The equations allow to switch to a two stage system with a CD in the top nest and CES
*  in the bottom nests.
*
*  The bottom nests are formally always there, but if each group only comprises one product,
*  the related equations which define quantities and prices collaps to simple assignments.
*
* -------------------------------------------------------------------------------------------------------------------

*
* --- define groups of products
*

*
*  --- that is an example for bottom nest definition for a specific data set
*

display
         p_priceShock
         p_techProgFac
;


$iftheni "%ds%"=="Vitor_split"

    set cgrp "consumption groups" /Cereals
                                   CoarseGrains
                                   Oiseeds
                                   OtherCrops
                                   Ruminants
                                   NonRuminants
                                   OtherMeat
                                   VegeOil
                                   Food
                                   Chemials
                                   Manufact
                                   Services
                                   CGDS
                                   RuminantMeat
    /;


 set cgrp_i(cgrp,i) "link consumption groups to individual products";
 cgrp_i(cgrp,i) $ sameas(cgrp,i) = YES;

 cgrp_i("RuminantMeat","RuminantMeat1") =YES;
 cgrp_i("RuminantMeat","RuminantMeat2") =YES;
$else


 set cgrp "consumption groups" / set.i /;

 set cgrp_i(cgrp,i) "link consumption groups to individual products";
$endif


 cgrp_i(cgrp,i) $ sameas(cgrp,i) = YES;

*        $prod:yt(j)$vtw(j)  s:1
*                 o:pt(j)           q:vtw(j)
*                 i:py(j,r)         q:vst(j,r)
*
*        -----------------------------------------------------------------------------
*
*        Profit function for private consumption (Cobb-Douglas):

parameter thetadpm(i,r)     "Product specific domestic expenditure share of private demand"
          thetaipm(i,r)     "Product specific expenditure share for imports of private demand"
          thetapm(i,r)      "Value share of good i in private consumption expenditure"
          thetapgrp(i,r)    "Value share of good i in product group expenditure"
          esubdgrp(cgrp)    "Substitution elasticity inside product groups"
;

*
* --- vdpm = value of private consumption from domestic origin at market prices
*     vipm = value of private consumption from imports at market prices
*
 thetadpm(i,r) $ ( vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r)))
         = vdpm(i,r)*(1+rtpd0(i,r)) /
                  (vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r)));

 thetaipm(i,r) $ ( vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r)))
         = vipm(i,r)*(1+rtpi0(i,r)) /
                  (vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r)));

*
* --- share of product i on total household expenditure for final
*     demand
*
 thetapm(i,r) = (vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r))) / vpm(r);



 thetapgrp(i,r) $ thetapm(i,r) = (vdpm(i,r)*(1+rtpd0(i,r))+vipm(i,r)*(1+rtpi0(i,r)))
                                  / sum(cgrp_i(cgrp,j) $ cgrp_i(cgrp,i), (vdpm(j,r)*(1+rtpd0(j,r))+vipm(j,r)*(1+rtpi0(j,r))));


Equations
   e_p_dc(i,r)      "Defines consumer price for domestic goods"
   e_p_ic(i,r)      "Defines consumer price for imported goods"
   e_p_c(i,r)       "Defines average consumer price"
   e_p_cgrp(cgrp,r) "Defines average consumer price for each group"

Variables
   p_dc(i,r)       "Consumer price for domestic goods"
   p_ic(i,r)       "Consumer price for imported goods"
   p_c(i,r)        "Average consumer price per product"
   p_cgrp(cgrp,r)  "Average consumer price per product group"
;
  esubdgrp(cgrp) = 10;

  esubdgrp(cgrp) $ (sum(cgrp_i(cgrp,i),1) eq 1) = 0;

*        User cost price indicies:

*
* --- Consumer price for domestic goods: output price plus ad-valorem tax
*
e_p_dc(i,r) $ thetadpm(i,r) ..

  p_dc(i,r) =E= py(i,r) * (1+rtpd(i,r)) / (1+rtpd0(i,r));

  p_dc.l(i,r) $ thetadpm(i,r)
              = py.l(i,r) * (1+rtpd(i,r)) / (1+rtpd0(i,r));

  p_dc.lo(i,r) = 1.E-6;

*
* --- Consumer price for imported goods: import price plus ad-valorem tax
*
 e_p_ic(i,r) $ thetaipm(i,r) ..

  p_ic(i,r) =E= pm(i,r)   * (1+rtpi(i,r)) / (1+rtpi0(i,r));

  p_ic.l(i,r) $ thetaipm(i,r)
              = pm.l(i,r) * (1+rtpi(i,r)) / (1+rtpi0(i,r));

  p_ic.lo(i,r) = 1.E-6;

*
* --- Average consumer prices: Armington (CES) from import and domestic
*
 e_p_c(i,r) $ thetapm(i,r) ..

  p_c(i,r) =E= (thetadpm(i,r)*p_dc(i,r)**(1-esubd(i)) $ thetadpm(i,r) +
                thetaipm(i,r)*P_ic(i,r)**(1-esubd(i)) $ thetaipm(i,r)      )**(1/(1-esubd(i)));

  p_c.l(i,r) $ thetapm(i,r)
             = (thetadpm(i,r)*p_dc.l(i,r)**(1-esubd(i)) $ thetadpm(i,r) +
                thetaipm(i,r)*P_ic.l(i,r)**(1-esubd(i)) $ thetaipm(i,r)   )**(1/(1-esubd(i)));

  pc.l(r) = 1 * %homogtest%;
  pc.lo(r) = 1.E-6;

*
*  --- CES aggregator for consumer group prices
*


 e_p_cgrp(cgrp,r) $ sum(cgrp_i(cgrp,i), thetapgrp(i,r)) ..

  p_cgrp(cgrp,r) =E= sum(cgrp_i(cgrp,i) $ thetapgrp(i,r),
                            thetapgrp(i,r) * p_c(i,r)**(1-esubdgrp(cgrp))
                        )**(1/(1-esubdgrp(cgrp)));

  p_cgrp.l(cgrp,r) = sum(cgrp_i(cgrp,i) $ thetapgrp(i,r),
                            thetapgrp(i,r) * p_c.l(i,r)**(1-esubdgrp(cgrp))
                        )**(1/(1-esubdgrp(cgrp)));
  p_cgrp.lo(cgrp,r) = 1.E-6;
  display p_cgrp.l;

*
*  --- consumer price index pc, aggregated accoring to CD demand function
*
  c.l(r) = 1;

  prf_c(r)..  prod(cgrp $ sum(cgrp_i(cgrp,i),thetapm(i,r)), p_cgrp(cgrp,r)**sum(cgrp_i(cgrp,i),thetapm(i,r))) =e= pc(r);

* -------------------------------------------------------------------------------------------------------------------
*
*  Public consumption block: price definitions, cost functions, deamnd function
*
* -------------------------------------------------------------------------------------------------------------------

*        $prod:c(r)  s:1  i.tl:esubd(i)
*                 o:pc(r)           q:vpm(r)
*                 i:py(i,r)         q:vdpm(i,r)       i.tl: p:(1+rtpd0(i,r)) a:ra(r) t:rtpd(i,r)
*                 i:pm(i,r)         q:vipm(i,r)       i.tl: p:(1+rtpi0(i,r)) a:ra(r) t:rtpi(i,r)
*        -----------------------------------------------------------------------------
*        Profit function for public consumption (Leontief):

 parameter thetadgm(i,r)  "Domestic value share in government demand"
          thetaigm(i,r)  "Import value share in government demand"
          thetagm(i,r)   "Aggregate value share in government demand";

 thetadgm(i,r) $ (vdgm(i,r)*(1+rtgd0(i,r))+vigm(i,r)*(1+rtgi0(i,r)))

         = vdgm(i,r)*(1+rtgd0(i,r)) /
                  (vdgm(i,r)*(1+rtgd0(i,r))+vigm(i,r)*(1+rtgi0(i,r)));

 thetaigm(i,r) $ (vdgm(i,r)*(1+rtgd0(i,r))+vigm(i,r)*(1+rtgi0(i,r)))

         = vigm(i,r)*(1+rtgi0(i,r)) /
                  (vdgm(i,r)*(1+rtgd0(i,r))+vigm(i,r)*(1+rtgi0(i,r)));

 thetagm(i,r) = (vdgm(i,r)*(1+rtgd0(i,r))+vigm(i,r)*(1+rtgi0(i,r))) / vgm(r);

*        User cost price indices:
Equations
   e_p_dg(i,r)   "Defines price paid by government for domestic goods"
   e_p_ig(i,r)   "Defines price paid by governmentfor imported goods"
   e_p_g(i,r)    "Defines average price paid by government "

Variables
   p_dg(i,r)     "Defines price paid by government for domestic goods"
   p_ig(i,r)     "Defines price paid by governmentfor imported goods"
   p_g(i,r)      "Defines average price paid by government ";



e_p_dg(i,r) $ thetadgm(i,r) ..

  p_dg(i,r) =E= py(i,r) * (1+rtgd(i,r)) / (1+rtgd0(i,r));

  p_dg.l(i,r)  $ thetadgm(i,r) = py.l(i,r) * (1+rtgd(i,r)) / (1+rtgd0(i,r));
  p_dg.lo(i,r) $ thetadgm(i,r) = 1.E-6;

e_p_ig(i,r) $ thetaigm(i,r) ..

  p_ig(i,r) =E= pm(i,r) * (1+rtgi(i,r)) / (1+rtgi0(i,r));

  p_ig.l(i,r)  $ thetaigm(i,r)= pm.l(i,r) * (1+rtgi(i,r)) / (1+rtgi0(i,r));
  p_ig.lo(i,r) $ thetaigm(i,r) = 1.E-6;

*        Unit cost functions (CES):

e_p_g(i,r) $ (thetadgm(i,r) or thetaigm(i,r))  ..

   p_g(i,r) =E= ( (thetadgm(i,r)*p_dg(i,r)**(1-esubd(i))) $ thetadgm(i,r) +
                  (thetaigm(i,r)*p_ig(i,r)**(1-esubd(i))) $ thetaigm(i,r)   )**(1/(1-esubd(i)));

   p_g.l(i,r) $ (thetadgm(i,r) or thetaigm(i,r))
              = ( (thetadgm(i,r)*p_dg.l(i,r)**(1-esubd(i)) ) $ thetadgm(i,r) +
                  (thetaigm(i,r)*p_ig.l(i,r)**(1-esubd(i)) ) $ thetaigm(i,r) )  **(1/(1-esubd(i)));
  p_g.lo(i,r) = 1.E-6;


   p_g.fx(i,r) $ ( not (thetadgm(i,r) or thetaigm(i,r))) = 1 * %homogTest%;

*        Leontief unit cost function:
*        (fixed consuption shares for government)

pg.l(r)  = 1 * %homogtest%;
pg.lO(r) = 1.E-6;

prf_g(r)..        sum(i,   thetagm(i,r) * p_g(i,r) ) =e= pg(r);


*        $prod:g(r)  s:0  i.tl:esubd(i)
*                 o:pg(r)           q:vgm(r)
*                 i:py(i,r)         q:vdgm(i,r)       i.tl: p:(1+rtgd0(i,r)) a:ra(r) t:rtgd(i,r)
*                 i:pm(i,r)         q:vigm(i,r)       i.tl: p:(1+rtgi0(i,r)) a:ra(r) t:rtgi(i,r)

*        -----------------------------------------------------------------------------
*        Profit function for bilateral trade aggregation:

*        User cost indices:
 Equations
   e_py_m  "Bilateral import price definition, domestic price at origina plus export taxes plus import tariffs"
   e_pt_m  "Bilateral import price plus transport margin"
   e_pyt_m
   e_cim
 ;

 variables
   py_m     "Bilateral import price net of transport costs"
   pt_m     "Sector specific bilateral transport cost, includes import tariffs"
   pyt_m
   cim
 ;


parameter         thetavxmd(i,s,r)   "Value share of product value plus export and import taxes in imports of good i"
                  thetavtwr(j,i,s,r) "Value share of transportation services from sector j in imports of good i"
                  thetam(i,s,r)      "Bilateral import value share";

thetavxmd(i,s,r)$(vxmd(i,s,r)*pvxmd(i,s,r) + sum(j,vtwr(j,i,s,r)*pvtwr(i,s,r)))
         = vxmd(i,s,r)*pvxmd(i,s,r) /
                  (vxmd(i,s,r)*pvxmd(i,s,r) + sum(j,vtwr(j,i,s,r)*pvtwr(i,s,r)));

thetavtwr(j,i,s,r)$(vxmd(i,s,r)*pvxmd(i,s,r) + sum(jj,vtwr(jj,i,s,r)*pvtwr(i,s,r)))
         = vtwr(j,i,s,r)*pvtwr(i,s,r) /
                  (vxmd(i,s,r)*pvxmd(i,s,r) + sum(jj,vtwr(jj,i,s,r)*pvtwr(i,s,r)));

rtxs(i,s,r) = -rtxs(i,s,r);


*
* --- import price: production price py in exporter region s
*                   plus export taxes rtxs, plus import tarrifs rtms
*
*                   pvxmd = benchmark import price
*

e_py_m(i,s,r) $ vxmd(i,s,r) ..

   py_m(i,s,r) =E= py(i,s) * (1+rtxs(i,s,r))*(1+rtms(i,s,r)) / pvxmd(i,s,r);

 py_m.l(i,s,r) $ vxmd(i,s,r)
   = py.l(i,s) * (1+rtxs(i,s,r))*(1+rtms(i,s,r)) / pvxmd(i,s,r);

 py_m.lo(i,s,r) $ vxmd(i,s,r) = 1.E-6;

*
* --- Sector specific per unit bilateral transport costs,
*     include import taxes
*
*
e_pt_m(j,i,s,r) $ thetavtwr(j,i,s,r) ..

   pt_m(j,i,s,r) =E= pt(j) * (1+rtms(i,s,r)) / pvtwr(i,s,r);

   pt.l(j) = 1 * %homogtest%;

 pt_m.l(j,i,s,r) $ thetavtwr(j,i,s,r)
   = pt.l(j) * (1+rtms(i,s,r)) / pvtwr(i,s,r);


thetam(i,s,r) $ vim(i,r)
         = (vxmd(i,s,r)*pvxmd(i,s,r) + sum(j,vtwr(j,i,s,r)*pvtwr(i,s,r)))/vim(i,r);

*        Price index of bilateral imports (Leontief cost function):

e_pyt_m(i,s,r) $ vxmd(i,s,r) ..

*
* --- import price plus transport margins
*
  pyt_m(i,s,r) =E= py_m(i,s,r)*thetavxmd(i,s,r) + sum(j, pt_m(j,i,s,r)*thetavtwr(j,i,s,r));

  pyt_m.l(i,s,r) $ vxmd(i,s,r)
   = py_m.l(i,s,r)*thetavxmd(i,s,r) + sum(j, pt_m.l(j,i,s,r)*thetavtwr(j,i,s,r));

  pyt_m.lo(i,s,r) $ vxmd(i,s,r) = 1.E-6;

*        Unit cost function for imports (CES):

e_cim(i,r) $ vim(i,r) ..

   cim(i,r) =E= sum(s $ thetam(i,s,r), thetam(i,s,r) * pyt_m(i,s,r)**(1-esubm(i)))**(1/(1-esubm(i)));

   cim.l(i,r) $ vim(i,r)
      = sum(s $ thetam(i,s,r), thetam(i,s,r) * pyt_m.l(i,s,r)**(1-esubm(i)))**(1/(1-esubm(i)));

prf_m(i,r) $ vim(i,r)..      cim(i,r) =e= pm(i,r);


*        $prod:m(i,r)$vim(i,r)      s:esubm(i)  s.tl:0
*                 o:pm(i,r)         q:vim(i,r)
*                 i:py(i,s)         q:vxmd(i,s,r)     p:pvxmd(i,s,r) s.tl:
*        +                 a:ra(s) t:(-rtxs(i,s,r))
*        +                 a:ra(r) t:(rtms(i,s,r)*(1-rtxs(i,s,r)))
*                 i:pt(j)#(s)       q:vtwr(j,i,s,r) p:pvtwr(i,s,r) s.tl:
*        +                 a:ra(r) t:rtms(i,s,r)
*        -----------------------------------------------------------------------------
parameter         thetavfm(f,j,r)   Value shares of specific factors;

   thetavfm(sf,j,r) $ evom(sf,r) = vfm(sf,j,r)/evom(sf,r);


Equation
 e_pvfm(f,r)
Variable
 pvfm(f,r)
;

e_pvfm(sf,r) $ evom(sf,r) ..

  pvfm(sf,r) =E= sum(j, thetavfm(sf,j,r) * ps(sf,j,r)**(1+etrae(sf)))**(1/(1+etrae(sf)));

  pvfm.l(sf,r) $ evom(sf,r) = sum(j, thetavfm(sf,j,r) * ps.l(sf,j,r)**(1+etrae(sf)))**(1/(1+etrae(sf)));


prf_ft(sf,r) $ evom(sf,r) ..  pf(sf,r) =e= pvfm(sf,r);

*        $prod:ft(sf,r)$evom(sf,r)  t:etrae(sf)
*                 o:ps(sf,j,r)      q:vfm(sf,j,r)
*                 i:pf(sf,r)        q:evom(sf,r)
*        -----------------------------------------------------------------------------
*        Demand functions:
*
*
*  WB: these equations and vars need to be properly documented
*
*
  Equation e_ddfm "Intermediate demand domestic"
           e_difm "Intermediate demand imports"
           e_dfm
           e_dst
           e_dpm(i,r) "Total final consumer demand definition (CD)"
           e_ddpm
           e_dipm
           e_ddgm
           e_digm
           e_dxmd
           e_dtwr;

  Variable ddfm
           difm
           dfm
           dst
           dpm(i,r) "Total final consumer demand"
           ddpm     "Final consumer demand domestic (Armington)"
           dipm     "Final consumer demand imported (Armington)"
           ddgm
           digm
           dxmd
           dtwr;


*
* --- intermediate demand, domestic and imports
*
   y.l(i,r)  = 1;
   y.lo(i,r) = 1.E-6;

e_ddfm(i,j,r) $ vdfm(i,j,r) ..

  ddfm(i,j,r) =E= (vdfm(i,j,r)*y(j,r)*(ci(i,j,r)/p_d(i,j,r))**esubd(i));

  ddfm.l(i,j,r) $ vdfm(i,j,r)
   = (vdfm(i,j,r)*y.l(j,r)*(ci.l(i,j,r)/p_d.l(i,j,r))**esubd(i));

e_difm(i,j,r) $ vifm(i,j,r) ..

   difm(i,j,r) =E= (vifm(i,j,r)*y(j,r)*(ci(i,j,r)/p_i(i,j,r))**esubd(i));

   difm.l(i,j,r) $ vifm(i,j,r)
         = (vifm(i,j,r)*y.l(j,r)*(ci.l(i,j,r)/p_i.l(i,j,r))**esubd(i));
*
* --- primary factor demand
*
e_dfm(f,j,r)  $ vfm(f,j,r) ..

   dfm(f,j,r)  =E= (vfm(f,j,r)*y(j,r)/p_techProgFac(j,r)*(cf(j,r)/p_pf(f,j,r))**esubva(j));

   dfm.l(f,j,r) $ vfm(f,j,r)
                = (vfm(f,j,r)*y.l(j,r)*(cf.l(j,r)/p_pf.l(f,j,r))**esubva(j));

   dfm.lo(f,j,r) $ vfm(f,j,r) = vfm(f,j,r) * 1.E-6;

*
* --- demand for international transport
*
yt.l(j) = 1;

e_dst(j,r)    $ vst(j,r) ..

   dst(j,r)  =E= (vst(j,r)*yt(j)*pt(j)/py(j,r));

   dst.l(j,r) $ vst(j,r)
    = (vst(j,r)*yt.l(j)*pt.l(j)/py.l(j,r));
*
* --- final household demand, domestic and internationnal
*
e_dpm(i,r) $ vdpm(i,r) ..


   dpm(i,r) =E=
*
*   --- total group demand according to CD (= fixed budget shares):
*                           spendings in benchmark (vdpm+dipm), plus sales taxes
*                           updated with change in total consumption c(r)
*                           corrected for change in group price related to overal price index
*
         sum(cgrp_i(cgrp,j) $ cgrp_i(cgrp,i), (vdpm(j,r)*(1+rtpd(j,r))+vipm(j,r)*(1+rtpi(j,r)))
                                    *c(r) * (pc(r)/p_cgrp(cgrp,r))
*
*   --- times share parameter
*
              * thetapgrp(i,r)
*
*   --- times price relation exponent the substitution elasticity
*
                * ( p_cgrp(cgrp,r)/p_c(i,r))**esubdgrp(cgrp)
             );

*
* --- Armington demand for domestic and imports
*
 dpm.l(i,r) = (vdpm(i,r)*(1+rtpd(i,r))+vipm(i,r)*(1+rtpi(i,r)));

e_ddpm(i,r)   $ vdpm(i,r) ..

   ddpm(i,r)  =E= dpm(i,r)/(1+rtpd(i,r))  * thetadpm(i,r)  * (p_c(i,r)/p_dc(i,r))**esubd(i);

   ddpm.l(i,r) $ vdpm(i,r)
               = dpm.l(i,r)/(1+rtpd(i,r)) * thetadpm(i,r)  * (p_c.l(i,r)/p_dc.l(i,r))**esubd(i);

e_dipm(i,r)  $ vipm(i,r) ..

   dipm(i,r)   =E= dpm(i,r)/(1+rtpi0(i,r)) * thetaipm(i,r) * (p_c(i,r)/p_ic(i,r))**esubd(i);

   dipm.l(i,r) $ vipm(i,r)
                 = dpm.l(i,r)/(1+rtpi0(i,r)) * thetaipm(i,r) * (p_c.l(i,r)/p_ic.l(i,r))**esubd(i);

*
* --- final government demand, domestic and international
*
  g.l(r) = 1;

e_ddgm(i,r) $ vdgm(i,r) ..

   ddgm(i,r)   =E= (vdgm(i,r)*g(r)*(p_g(i,r)/p_dg(i,r))**esubd(i));

   ddgm.l(i,r) $ vdgm(i,r)
     = (vdgm(i,r)*g.l(r)*(p_g.l(i,r)/p_dg.l(i,r))**esubd(i));

e_digm(i,r) $ vigm(i,r) ..

  digm(i,r)   =E= (vigm(i,r)*g(r)*(p_g(i,r)/p_ig(i,r))**esubd(i));

  digm.l(i,r) $ vigm(i,r)
    = (vigm(i,r)*g.l(r)*(p_g.l(i,r)/p_ig.l(i,r))**esubd(i));
*
* --- export demand, bilateral
*
  m.l(i,r) = 1;
*
e_dxmd(i,s,r) $ vxmd(i,s,r) ..

  dxmd(i,s,r) =E= (vxmd(i,s,r) * m(i,r)   * (pm(i,r)  /pyt_m(i,s,r)  )**esubm(i));

  dxmd.l(i,s,r) $ vxmd(i,s,r)
               = (vxmd(i,s,r)  * m.l(i,r) * (pm.l(i,r)/pyt_m.l(i,s,r))**esubm(i));
*
* --- bilateral trade margins
*     (proportional to export demand for product i)
*
e_dtwr(j,i,s,r) $ vtwr(j,i,s,r) ..

  dtwr(j,i,s,r) =E= ( vtwr(j,i,s,r) * m(i,r) * (pm(i,r)/pyt_m(i,s,r) )**esubm(i));

  dtwr.l(j,i,s,r) $ vtwr(j,i,s,r)
                  = (vtwr(j,i,s,r)*m.l(i,r)*(pm.l(i,r)/pyt_m.l(i,s,r))**esubm(i));

*
*        -----------------------------------------------------------------------------
*
*        Regional tax revenue by tax instrument:
*
*        -----------------------------------------------------------------------------
*
*  WB: these equations and vars need to be properly documented
*
equation e_revto(r)   "Tax revenue from output taxes"
         e_revtfd(r)
         e_revtfi(r)
         e_revtf(r)
         e_revtpd(r)
         e_revtpi(r)
         e_revtgd(r)
         e_revtgi(r)
         e_revtxs(r)
         e_revtms(r)
;

variable revto(r)
         revtfd(r)
         revtfi(r)
         revtf(r)
         revtpd(r)
         revtpi(r)
         revtgd(r)
         revtgi(r)
         revtxs(r)
         revtms(r)
;

e_revto(r) ..
    revto(r) =E= sum(j$vom(j,r), rto(j,r) * vom(j,r) * py(j,r) * y(j,r));
    revto.l(r) = sum(j$vom(j,r), rto(j,r) * vom(j,r) * py.l(j,r) * y.l(j,r));


e_revtfd(r)..

   revtfd(r) =E= sum((i,j) $ vdfm(i,j,r), rtfd(i,j,r) * py(i,r) * ddfm(i,j,r));
   revtfd.l(r) = sum((i,j) $ vdfm(i,j,r), rtfd(i,j,r) * py.l(i,r) * ddfm.l(i,j,r));

e_revtfi(r)..

  revtfi(r) =E= sum((i,j) $ vifm(i,j,r), rtfi(i,j,r)*pm(i,r)*difm(i,j,r));
  revtfi.l(r) = sum((i,j) $ vifm(i,j,r), rtfi(i,j,r)*pm.l(i,r)*difm.l(i,j,r));

e_revtf(r) ..

  revtf(r) =E= sum((f,j) $ vfm(f,j,r), rtf(f,j,r)*pf(f,r)*dfm(f,j,r));
  revtf.l(r) = sum((f,j) $ vfm(f,j,r), rtf(f,j,r)*pf.l(f,r)*dfm.l(f,j,r));

e_revtpd(r) ..

 revtpd(r) =E= sum(i$vdpm(i,r), rtpd(i,r) * py(i,r) * ddpm(i,r));
 revtpd.l(r) = sum(i$vdpm(i,r), rtpd(i,r) * py.l(i,r) * ddpm.l(i,r));

e_revtpi(r) ..

 revtpi(r) =E= sum(i$vipm(i,r), rtpi(i,r) * pm(i,r) * dipm(i,r));
 revtpi.l(r) = sum(i$vipm(i,r), rtpi(i,r) * pm.l(i,r) * dipm.l(i,r));

e_revtgd(r) ..

 revtgd(r) =E= sum( i $ vdgm(i,r), rtgd(i,r) * py(i,r) * ddgm(i,r));
 revtgd.l(r) = sum( i $ vdgm(i,r), rtgd(i,r) * py.l(i,r) * ddgm.l(i,r));

e_revtgi(r) ..

 revtgi(r) =E= sum(i $ vigm(i,r), rtgi(i,r) * pm(i,r) * digm(i,r));
 revtgi.l(r) = sum(i $ vigm(i,r), rtgi(i,r) * pm.l(i,r) * digm.l(i,r));

e_revtxs(r) ..

  revtxs(r) =E= sum((i,s) $ vxmd(i,r,s), rtxs(i,r,s) * py(i,r) * dxmd(i,r,s));
  revtxs.l(r) = sum((i,s) $ vxmd(i,r,s), rtxs(i,r,s) * py.l(i,r) * dxmd.l(i,r,s));

e_revtms(r) ..

  revtms(r) =E= sum((i,s) $ thetam(i,s,r), rtms(i,s,r) *
         (py(i,s)*(1+rtxs(i,s,r))*dxmd(i,s,r) + sum(j $ vtwr(j,i,s,r), pt(j) * dtwr(j,i,s,r))));

  revtms.l(r) = sum((i,s) $ thetam(i,s,r), rtms(i,s,r) *
         (py.l(i,s)*(1+rtxs(i,s,r))*dxmd.l(i,s,r) + sum(j $ vtwr(j,i,s,r), pt.l(j) * dtwr.l(j,i,s,r))));

*        -----------------------------------------------------------------------------
*        Income balance consition:



inc_ra(r) $ (ra.lo(r) < ra.up(r))..
*
*        --- ra(r) = value of total household consumption
*
         ra(r) =e=
*
*                          --- vb * pc(rnum) = current account balance, at consumer price index
*                                              of numeraire region
*
                           sum(rnum, pc(rnum)*vb(r))
*
*                          --- government demand
*
                           - pg(r)*vgm(r)
*
*                          --- investment demand
*
                           - sum(i, py(i,r) * vdim(i,r))
*
*                          --- factor income
*
                           + sum( (f,j) $ vfm(f,j,r), pf(f,r) * dfm(f,j,r))
*
*                          --- tax income from various sources
*
                           + revto(r)
                           + revtfd(r)
                           + revtfi(r)
                           + revtf(r)
                           + revtpd(r)
                           + revtpi(r)
                           + revtgd(r)
                           + revtgi(r)
                           + revtxs(r)
                           + revtms(r);

*        $demand:ra(r)
*                 d:pc(r)           q:vpm(r)
*                 e:pc(rnum)        q:vb(r)
*                 e:pg(r)           q:(-vgm(r))
*                 e:py(i,r)         q:(-vdim(i,r))
*                 e:pf(f,r)         q:evom(f,r)

*        -----------------------------------------------------------------------------
*
*        Market clearance associated with private consumption:

*
*          c(r)    consumption index
*          vpm(r)  private consumption in base
*          pc(r)   consumer price index
*
mkt_pc(r)..                c(r) * vpm(r) * pc(r) =e= ra(r);

*        -----------------------------------------------------------------------------
*        Market clearance associated with public consumption:

mkt_pg(r)..                g(r) =e= 1;

*        -----------------------------------------------------------------------------
*        Market clearance associated with firm output:

mkt_py(i,r) $ vom(i,r) ..

         y(i,r) * vom(i,r) =e=
*
*                               --- intermediate demand for domestic sales
*
                                   sum(j $ vdfm(i,j,r), ddfm(i,j,r))
*
*                               --- household demand for domestic sales
*
                                 + ddpm(i,r) $ vdpm(i,r)
*
*                               --- government demand for domestic sales
*
                                 + ddgm(i,r) $ vdgm(i,r)
*
*                               --- export demand
*
                                 + sum(s $ vxmd(i,r,s), dxmd(i,r,s))
*
*                               --- demand for international transportation
*
                                 + dst(i,r) $ vst(i,r)
*
*                               --- investment demand
*
                                 + vdim(i,r);

*
*        -----------------------------------------------------------------------------
*
*        Market clearance associated with imports:
*
*        m(i,r)    import quantity index
*        vim(i,r)  import quantity in base
*

mkt_pm(i,r) $ vim(i,r)..     m(i,r) * vim(i,r) =e=
*
*                                                      --- intermediate demand for imports
*
                                                         sum(j $ vifm(i,j,r), difm(i,j,r))
*
*                                                      --- private demand for imports
*
                                                       + dipm(i,r) $ vipm(i,r)
*
*                                                      --- government demand for imports
*
                                                       + digm(i,r) $ vigm(i,r);
*
*        -----------------------------------------------------------------------------
*
*        Market clearance associated with transport services:

mkt_pt(j) $ vtw(j)..         yt(j) * vtw(j) =e= sum((i,s,r) $ vtwr(j,i,s,r), dtwr(j,i,s,r));


*
*        -----------------------------------------------------------------------------
*
*        Market clearance associated with primary factors:
*
mkt_pf(f,r) $ (evom(f,r) $ (not fpf(f))) ..    evom(f,r) =e= sum(j $ vfm(f,j,r), dfm(f,j,r)) $ mf(f) + (evom(f,r)*ft(f,r))$sf(f);
*
ft.l(sf,r) = 1;
*
*        -----------------------------------------------------------------------------
*
*        Market clearance associated with specific factors:

mkt_ps(sf,j,r) $ vfm(sf,j,r)..
*
         vfm(sf,j,r) * (ps(sf,j,r)/pf(sf,r))**etrae(sf) =e= dfm(sf,j,r);


equation e_dummy;variable dobje;
e_dummy .. dobje =E= 10;

dobje.l = 10;

model gtap6mcp /

         prf_c.c,
         prf_g.g,
         prf_y.y,
         prf_m.m,
         prf_yt.yt,
         prf_ft.ft,
         mkt_pc.pc,
         mkt_pg.pg,
         mkt_py.py,
         mkt_pm.pm,
         mkt_pt.pt,
         mkt_pf.pf,
         mkt_ps.ps,
         inc_ra.ra
         e_cf.cf
         e_ci.ci
         e_cy.cy

         e_p_pf.p_pf
         e_p_d.p_d
         e_P_i.P_i

         e_p_dc.p_dc
         e_p_ic.p_ic
         e_p_c.p_c
         e_p_cgrp.p_cgrp

         e_p_dg.p_dg
         e_p_ig.p_ig
         e_p_g.p_g

         e_py_m.py_m
         e_pt_m.pt_m
         e_pyt_m.pyt_m
         e_cim.cim


         e_pvfm.pvfm
*
*        --- tax income equations

         e_revto.revto
         e_revtfd.revtfd
         e_revtfi.revtfi
         e_revtf.revtf
         e_revtpd.revtpd
         e_revtpi.revtpi
         e_revtgd.revtgd
         e_revtgi.revtgi
         e_revtxs.revtxs
         e_revtms.revtms

         e_ddfm.ddfm
         e_difm.difm
         e_dfm.dfm
         e_dst.dst
         e_dpm.dpm
         e_ddpm.ddpm
         e_dipm.dipm
         e_ddgm.ddgm
         e_digm.digm
         e_dxmd.dxmd
         e_dtwr.dtwr

  /;

model gtap6Cns / gtap6mcp,e_dummy /;

gtap6cns.holdfixed = 1;
gtap6mcp.holdfixed = 1;



*        Assign default values:

ra.l(r) = vpm(r) * %homogTest%;


*        Fix variables which should not enter the model:

y.fx(i,r)     $ (vom(i,r)=0)                    = 1;
m.fx(i,r)     $ (vim(i,r)=0)                    = 1;
yt.fx(j)      $ (vtw(j)=0)                      = 1;

py.fx(j,r)    $ (vom(j,r)=0)                    = 1 * %homogTest%;
pm.fx(j,r)    $ (vim(j,r)=0)                    = 1 * %homogTest%;
pt.fx(j)      $ (vtw(j)=0)                      = 1 * %homogTest%;
pf.fx(f,r)    $ (evom(f,r)=0)                   = 1 * %homogTest%;
ps.fx(f,j,r)  $ ((not sf(f)) or (vfm(f,j,r)=0)) = 1 * %homogTest%;
ft.fx(f,r)    $ ((not sf(f)) or (evom(f,r)=0))  = 1 ;

*
* --- fixed price = endogenous change in endowment
*
p_pf.fx(f,j,r)    $ fpf(f) = p_pf.l(f,j,r) * %homogTest%;
pf.fx(f,r)        $ fpf(f) = pf.l(f,r);

*        Establish a price normalization using the reference region:
display rnum;
 ra.fx(rnum) = ra.l(rnum);

*  pc.fx(rnum) = %homogTest%;
* display sf;

*$include 'sim_input.gms'
*
* --- solve benchmark
*
$iftheni %modeltype% == MCP

   gtap6mcp.iterlim = 0;
   solve gtap6mcp using mcp;

$else

* --- Verify benchmark consistency with both MCP and CNS models:

  gtap6cns.iterlim = 0;
  solve gtap6cns using nlp minimizing dobje;

$endif
*
* --- include shock
*



display
         evom
;

$iftheni %modeltype% == MCP

$setglobal model gtap6Mcp

*  --- Verify consistency of the solution using the MCP model:

   gtap6mcp.iterlim = 10000;
   solve gtap6mcp using mcp;

$elseifi %modeltype% == none
*
*  --- no solve, to produce very large result sets to view
*

$else

$setglobal model gtap6Cns

   gtap6cns.optfile = 1;
   gtap6cns.iterlim = 10000;
   solve gtap6cns using nlp minimizing dobje;

$endif

*
* --- map most variable back into a SAM like structure
*     which can be inspected
*
$include 'report.gms'


$ifi not %modeltype% == none $exit


*
* --- generate convert output for equation / variable viewer
*
execute "echo gams convert_gtap6cns.gms > convert.opt";
execute "echo dict convert_gtap6cns.txt >> convert.opt";
option nlp=convert;
gtap6cns.optfile =1;
solve gtap6cns using nlp minimizing dobje;

